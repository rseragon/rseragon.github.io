---
title: Wait! what? UB? wdym?
author:
  name: rseragon
  link: https://github.com/rseragon
date: 2022-12-03 10:48:03 +0530
categories: [C/C++, beginner]
tags: [UB, C, Cpp]
---

If you have ever programmed in C or C++, you would have heard the term UB (if not,
then this article isn't for ya neophyte). UB stands for **U**ndefiend **B**ehavior,
i.e. the behavior is not defined by the standard[^standard] and can result to anything 
like a run time error, Seg Fault, or insane amounts of cat fur in your blanket.

### TL;DR
> UB(Undefined Behavior) is the unpredictable behavior by the program 
> generated by the compiler which might vary from architecture to architecture 
> and compiler to compiler. There are no rules which bind the output of the program 
> and can lead to termination of the program itself by a Seg fault or a 
flight to fall from a high 
> altitude beacuse the altitude variable overflowed. An example for it would be 
> accessing an array out of its bounds or dereferencing a wild pointer.


## What exactly is UB?
Ever wasted 3 hours of your life banging the head to the wall just to find out that a simple 
unsigned subtraction caused an integer underflow leading to a Seg fault in your program. 

- > No?!?<br/>
Then you might prefer to continue reading the article.
- > Yes!?<br/> 
Then there is a 100% chance that is because of a UB, and I urge to read this article.

For the starters, let's go with the basic definition. Here's a definition from [C FAQ](https://c-faq.com/):
> "Anything at all can happen; the Standard imposes no requirements. The program may 
> fail to compile, or it may execute incorrectly (either crashing or silently 
> generating incorrect results), or it may fortuitously do exactly what the 
> programmer intended."

*So, a UB can cause anything... isn't that bad?*<br />
Yes! it is bad and most of the times, it can be avoided by the 
programmer by being a bit cautious (Excluding the atrocities caused by the 
compiler itself [^atrocities_of_compiler] ).

Let's take a look at few example for better understanding.

Consider this following code
```c
#include <stdio.h>

int main(void) {
  
  int *p; // A wild pointer has appeared!

  printf("%p\n", p);
  printf("%d\n", *p);

  return 0;
}
```
{: file="wild_ptr.c"}


Output with **gcc** (v11.1.0)
```console
❯ gcc wild_ptr.c -o gcc.out && ./gcc.out
(nil)
[1]    535911 segmentation fault (core dumped)  ./gcc.out
```

Output with **clang** (v13.0.0)
```console
❯ clang wild_ptr.c -o clang.out && ./clang.out
0x7ffe3f0922f0
1
```

Output with **tcc** (v0.9.27)
```console
❯ tcc wild_ptr.c -o tcc.out && ./tcc.out
(nil)
[1]    537963 segmentation fault (core dumped)  ./tcc.out
```
([Wanna try out in more compilers?](https://godbolt.org/z/4fqnq5xY6){: target="_blank"})

![wild ptr](https://cdn.jsdelivr.net/gh/rseragon/rseragon.github.io@master/assets/gif/ub/wild_ptr.gif)
(Here, P is getting assigned to a random address, which might point to any block in memory) <br />
Considering the compilers now, the outputs from GCC and TCC are the same leading to a Seg fault.<br/>

*BUT Clang gets it right! So, clang is the best compiler, right?*<br />

If you are thinking like this, consider this example:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
  
  char* str = malloc(sizeof(char) * 10);

  strcpy(str, "Some String which will overflow");

  printf("%s\n", str);

  return 0;
}

```
{: file="buffer_overflow.c"}

Output with **gcc** (v11.1.0)
```console
❯ gcc buffer_oveflow.c -o gcc.out
buffer_oveflow.c: In function ‘main’:
buffer_oveflow.c:9:3: warning: ‘__builtin_memcpy’ writing 32 bytes into a region of size 10 overflows the destination [-Wstringop-overflow=]
    9 |   strcpy(str, "Some String which will overflow");
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
buffer_oveflow.c:7:15: note: destination object of size 10 allocated by ‘malloc’
    7 |   char* str = malloc(sizeof(char) * 10);
      |               ^~~~~~~~~~~~~~~~~~~~~~~~~

❯ ./gcc.out
malloc(): corrupted top size
[1]    589156 abort (core dumped)  ./overflow.out
```

Output with **clang** (v13.0.0)
```console
❯ clang buffer_overflow.c -o clang.out

❯ ./clang.out
malloc(): corrupted top size
[1]    590478 abort (core dumped)  ./clang.out

```
In this case, Clang did not produce any error at all[^gomen-nasai]. But,
GCC warned the user about the String operation overflow; *So, is GCC the best compiler?*<br />
If you are asking about the best compiler... we could have a debate
until the end of the eternity. Keeping that aspect of deciding which
compiler is the best apart. If we look at the output of both of the binaries 
generated by the compilers, we can notice that they are pretty much the same.

But this might vary from your computer to my computer, or from GCC or MSVC or Clang.
This is the reason it is called a UB, since we are unable to predict what might 
happen; it's a programmers nightmare!

## So, how do we fix it now?
Most of these errors, can be fixed easily by the programmer being cautious about
what he is trying to achieve and how the compiler perceives it. It might be a 
tedious task, but it's better not have any UB lurking inside your code, waiting 
for a perfect saturday to manifest itself and destroy your weekend!

For example consider the above code where we derefernced a wild pointer, 
fixing it is as easy as a walk in the park. (unless you are an introvert)

- An easy solution would be to always intialize a poitner with `NULL`
```c
...
  int *p = NULL;
...
```
![NULL ptr](https://cdn.jsdelivr.net/gh/rseragon/rseragon.github.io@master/assets/gif/ub/null_ptr.gif)


*So, I've fixed the UB, now can I access the pointer `p`?* <br />
Do you expect to time travel if you jump into the black hole? No! you'll be shreded into
bits before you even reach the event horizon.<br />
Remember **DO NOT** dereference a `NULL` pointer, it'll definitely lead to a Seg fault.


*B-but, you just said that you need to always initialize poitners with `NULL`?*<br />
Yes! but don't dereference it yet, assign or allocate it some memory and then 
dereference it. Like: 

```c
...
p = (int *) malloc(sizeof(int) * 177013);
...
```
![good ptr](https://cdn.jsdelivr.net/gh/rseragon/rseragon.github.io@master/assets/gif/ub/good_ptr.gif)

## Aren't there any general solutions for this?
 Unforutnately, there ain't any general solution for all of these UBs. The programmer has to
identify them manually and come up with a solution.<br />
But there are some practices which you can follow:
  - Enable compiler diagnostic messages (`-W<flag>`)
  - Use compiler built-in Sanitizers (eg: `-fsanitize-address`)
  - Use static analyzers to get more warnings
  - Check for memory leaks using valgrind
  - Use a good debugger(like gdb, lldb, ...)
  - And many more!


## Why do they exist?
Now that you know a bit of what UB is[^ReadMore], I would like to give you my opinion why
this obscure construct still exsists and why can't the standard commitee abolish and bring
peace and glory. (Note: My opinion on this can by **very** based, but here you go.)
- _Speed_ <br />
  Checking for UB either on run time or compile time might just bring an extra overload on
  the program which would affect its precious runtime speed. And as many of the low level 
  drivers, kernels are written in C, it might break few API's/funtions and can bring the 
  whole hell onto the maintainers head.
- _Size_ <br />
  Adding in these run time check might just bloat the program with unwanted clutter, and
  might lead to bigger executable size.
- _Quality_ <br />
  Ever thought of using UB as feature? yeah, you read it right! there are few(a very few),
  programs out there which take advantage of UB to apply ethereal rocket science mechanics
  into their working. And messing with these historical relics might just call the cthulhu!
- _History_ <br />
  Many of the low level programs are old and are meant to be reliable, putting the programs built with it aside, 
  the langauage itself is pretty
  old and bringing a heavy paradigm shift which might affect the entire structural design of the language
  is something... which cannot be done. :()
- _Laziness_ <br />
  It's self explanatory. 
  There was a time when an extra stray double quote(`"`) was declared as a UB by the standard 



---
# References and further reading
- [Nasal demons](http://catb.org/jargon/html/N/nasal-demons.html)
- [What Every C Programmer Should Know About Undefined Behavior #1/3](https://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html)
- [A Guide to Undefined Behavior in C and C++, Part 1](https://blog.regehr.org/archives/213)
- [Undefined Behavior Consequences Contest Winners(John Regehr)](https://blog.regehr.org/archives/767)
- [c-faq](http://c-faq.com)

---

[^standard]: The ISO [C](https://www.open-std.org/jtc1/sc22/wg14/) and [C++](https://isocpp.org/std/the-standard) standard
[^atrocities_of_compiler]: There are many situation where UB's are caused by the compilers "over-optimizations", so it's not entierly the programmers fault
[^gomen-nasai]: This is a case where I've not used any compiler arguments. It could have been a different case if ASan or any other compiler args would have been used.
[^ReadMore]: This article just barely scratches the surface of few abominations a UB can do. If you wanna read more about it look at the [References](#references-and-further-reading) or just google :D

